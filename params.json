{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"UA-33820770-1","name":"restlib2","tagline":"restlib2 is an HTTP library which simplifies creating dynamic Web resources for Django. restlib2 focuses on embracing HTTP and enables clean transparent implementations of your resources.","body":"Django RESTlib: HTTP for Programmers\r\n====================================\r\nRESTlib2 is an HTTP library which simplifies\r\ncreating dynamic Web resources in Python. RESTlib2 focuses on embracing\r\nHTTP and enables clean transparent implementations of your resources.\r\n\r\nWhy?\r\n----\r\nWeb frameworks typically layer on the abstractions for handling\r\nthe request/response process. These abstractions decrease implementation\r\ntransparency and results in fragmented modifications of your response\r\nobject.\r\n\r\n[Django][2], for example, is a full stack Web framework which has a\r\n[middleware layer][3] that enables processing and/or augmenting the request\r\nand response objects before and after the _view_ (called a controller in\r\nMVC stacks) processes the request. Along with the middleware, there are\r\n[numerous][4] [decorators][5] which can be used to wrapped the view to\r\nmodify the process the request headers or modify the response headers.\r\n\r\nDjango is not at fault here. It was not designed to provide a REST API\r\nwith the notion of a _resource_. It's background and intent is\r\nto make it trivial to stand up websites and the core developers (and\r\nthe community) take an extremely pragmatic approach to achieve this.\r\nThat being said, for very simple APIs Django has a few [helper functions][6]\r\nfor restricting which methods are allowed.\r\n\r\nAside from Django core, [django-tastypie][7] is the most popular app that\r\nprovides an API for defining resources in Django. Unfortunately, tastypie\r\nhas too complicated of an API and too many abstractions to understand\r\nhow it works. The developer must work within the confines of this intricate\r\nand arbitrary API, rather than embracing and confidently working with\r\nthe inferred _API_ HTTP provides.\r\n\r\nRESTlib2 intends to provide a more simple, natural and familiar API for\r\ncreating dynamic Web resources in Python.\r\n\r\n[1]: http://python-requests.org\r\n[2]: http://www.djangoproject.com\r\n[3]: https://docs.djangoproject.com/en/1.3/ref/middleware/\r\n[4]: https://docs.djangoproject.com/en/1.3/topics/conditional-view-processing/\r\n[5]: https://docs.djangoproject.com/en/1.3/topics/http/decorators/\r\n[6]: https://docs.djangoproject.com/en/1.4/topics/http/decorators/#allowed-http-methods\r\n[7]: http://django-tastypie.readthedocs.org/en/latest/index.html\r\n\r\nExamples\r\n--------\r\n\r\n**Barebone Example** (no sugar)\r\n\r\n```python\r\nimport json\r\n\r\nclass Author(Resource):\r\n    supported_accept_types = ['application/json']\r\n\r\n    def get(self, request):\r\n        return json.dumps([{\r\n            'first_name': 'John',\r\n            'last_name': 'Doe',\r\n            'birth_date': '1954-03-29',\r\n        }, {\r\n            'first_name': 'Jane',\r\n            'last_name': 'Doh',\r\n            'birth_date': '1958-01-13',\r\n        }])\r\n```\r\n\r\n* ``supported_accept_types`` defines the supported encoding types and rejects\r\n  requests only does not accept `application/json`\r\n* Since the `get` method is only defined, `post`, `put`, `patch`, and\r\n  `delete` are not allowed for this resource. `head` is accessible if\r\n  `get` is defined and `options` is always available unless the service\r\n  is set as unavailable\r\n\r\nComposite Resources\r\n------------------\r\nWhen designing a REST API, an important decision to make up front is\r\nwhether a _chatty_ service is preferred, or a service that requires\r\nmore bandwith per request.\r\n\r\nThe latter of the two is a result of embedding resources in other related\r\nresources. For example, the first response entity below simply has a\r\nreference to the endpoint where author `id` is available. Thus in order to\r\nget the data about the author, a second request is required.\r\n\r\nThe second response entity has the author data embedded in the book data.\r\nThis will require more bandwith, but will not require subsequent requests.\r\n\r\n```javascript\r\n// Referenced\r\n{\r\n    \"title\": \"Learn Python The Hard Way\",\r\n    \"publish_date\": \"2010-05-01\",\r\n    \"author\": {\r\n        \"id\": 1,\r\n        \"url\": \"http://example.com/author/1\"\r\n    }\r\n}\r\n\r\n// Embedded\r\n{\r\n    \"id\": 1,\r\n    \"title\": \"Learn Python The Hard Way\",\r\n    \"publish_date\": \"2010-05-01\",\r\n    \"author\": {\r\n        \"id\": 1,\r\n        \"first_name\": \"Zed\",\r\n        \"last_name\": \"Shaw\"\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nDeciding whether to embed data in another entity can be answered with a\r\nsimple question:\r\n\r\n> Is it likely the two entities are represented together in client\r\napplications?\r\n\r\nNote that embedding resources does not preclude resources from having their\r\nown endpoints (as in the first example).\r\n\r\nFor a large collection of objects, choosing to not embed related resources\r\nresults in the client needing to potentially make hundreds or thousands\r\nadditional requests.\r\n\r\nIt is recommended to use [django-preserialize](http://bruth.github.com/django-preserialize/)\r\nfor easily creating custom nested objects. By default, preserialize will recursively embed\r\nany local fields and local related objects.\r\n\r\n```python\r\nfrom preserialize.serialize import serialize\r\nfrom library.models import Book\r\n\r\nclass Author(Resource):\r\n    supported_accept_types = ['application/json']\r\n\r\n    def get(self, request):\r\n        data = serialize(Book.objects.all())\r\n        return json.dumps(data)\r\n```\r\n\r\nFor a bit more control, the fields to be included or excluded can be specified:\r\n\r\n```\r\nfrom preserialize.serialize import serialize\r\nfrom library.models import Book\r\n\r\nclass Author(Resource):\r\n    supported_accept_types = ['application/json']\r\n\r\n    def get(self, request):\r\n        author_template = {\r\n            'fields': ['first_name', 'last_name']\r\n        }\r\n\r\n        book_template = {\r\n            'fields': ['id', 'title', 'publish_date', 'author']\r\n            # Define the serialization template for the related author\r\n            'related': {\r\n                'author': author_template,\r\n            }\r\n        }\r\n        data = serialize(Book.objects.all(), **book_template)\r\n        return json.dumps(data)\r\n```\r\n\r\n\r\nPhilosophy\r\n----------\r\n\r\n* **Be pragmatic.** Don't attempt to solve the world's problems in a single\r\n  resource. Each should be written with equal purpose in mind.\r\n* **Keep it simple.** Don't concern yourself with the details until you\r\n  absolutely need to. Setting a plethora of headers will only make things\r\n  more complicated.\r\n* **Be consistent.** If you make use of HATEOAS (and you should), use it\r\n  everywhere it makes sense. Support the same mimetypes across your service.\r\n* **Keep it visible.** Resources should be as _visible_ as possible. Do not\r\n  obfuscate or overcomplicate how a request is handled, otherwise processing\r\n  becomes non-deterministic.\r\n"}