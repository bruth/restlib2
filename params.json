{"google":"UA-33820770-1","tagline":"restlib2 is an HTTP library which simplifies creating dynamic Web resources for Django. restlib2 focuses on embracing HTTP and enables clean transparent implementations of your resources.","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"## Overview\r\n\r\nInspired by [Requests][1], RESTlib2 is an HTTP library which simplifies\r\ncreating dynamic Web resources in Python. RESTlib2 focuses on embracing\r\nHTTP and enables clean transparent implementations of your resources.\r\n\r\n**This is very much a work on progress, but the current code is\r\nwell-tested works as expected.**\r\n\r\n### Why?\r\n\r\nWeb frameworks typically layer on the abstractions for handling\r\nthe request/response process. These abstractions decrease implementation\r\ntransparency and results in fragmented modifications of your response\r\nobject.\r\n\r\n[Django][2], for example, is a full stack Web framework which has a\r\n[middleware layer][3] that enables processing and/or augmenting the request\r\nand response objects before and after the _view_ (called a controller in\r\nMVC stacks) processes the request. Along with the middleware, there are\r\n[numerous][4] [decorators][5] which can be used to wrapped the view to\r\nmodify the process the request headers or modify the response headers.\r\n\r\nDjango is not at fault here. It was not designed to provide a REST API\r\nwith the notion of a _resource_. It's background and intent is\r\nto make it trivial to stand up websites and the core developers (and\r\nthe community) take an extremely pragmatic approach to achieve this.\r\n\r\nAside from Django core, [django-tastypie][6] is the most popular app that\r\nprovides an API for defining resources in Django. Unfortunately, tastypie\r\nhas too complicated of an API and too many abstractions to understand\r\nhow it works. The developer must work within the confines of this intricate\r\nand arbitrary API, rather than embracing and confidently working with\r\nthe inferred _API_ HTTP provides.\r\n\r\nRESTlib2 intends to provide a more simple, natural and familiar API for\r\ncreating dynamic Web resources in Python.\r\n\r\n[1]: http://python-requests.org\r\n[2]: http://www.djangoproject.com\r\n[3]: https://docs.djangoproject.com/en/1.3/ref/middleware/\r\n[4]: https://docs.djangoproject.com/en/1.3/topics/conditional-view-processing/\r\n[5]: https://docs.djangoproject.com/en/1.3/topics/http/decorators/\r\n[6]: http://django-tastypie.readthedocs.org/en/latest/index.html\r\n\r\n### Philosophy\r\n\r\n* **Be pragmatic.** Don't attempt to solve the world's problems in a single\r\n  resource. Each should be written with equal purpose in mind.\r\n* **Keep it simple.** Don't concern yourself with the details until you\r\n  absolutely need to. Setting a plethora of headers will only make things\r\n  more complicated.\r\n* **Be consistent.** If you make use of HATEOAS (and you should), use it\r\n  everywhere it makes sense. Support the same mimetypes across your service.\r\n* **Keep it visible.** Resources should be as _visible_ as possible. Do not\r\n  obfuscate or overcomplicate how a request is handled, otherwise processing\r\n  becomes non-deterministic.\r\n\r\n---\r\n\r\n## Features\r\n\r\n* Familiar API for defining resources using common HTTP terminology\r\n* Simple API for fully embedding resources or referencing resources by\r\n  their own endpoint (see [HATEOAS][7])\r\n* Resource methods (e.g. `get`, `put`, `post`) have access to both the\r\n  `request` and `response` objects. Augment the response object as needed.\r\n* Support for defining versions of a resource in the `Content-Type`, e.g.\r\n  `application/json, version=1`\r\n* Abstract `Resource` class for quick integration with your favorite\r\n  Web framework\r\n* Built-in implementions for common Web frameworks including Django,\r\n  and Werkzeug\r\n\r\n[7]: http://en.wikipedia.org/wiki/HATEOAS\r\n\r\n---\r\n\r\n## Examples\r\n\r\n**Barebone Example** (no sugar)\r\n\r\n```python\r\nimport json\r\n\r\nclass Author(Resource):\r\n    supported_accept_types = ['application/json']\r\n\r\n    def get(self, request, response):\r\n        return json.dumps([{\r\n            'first_name': 'John',\r\n            'last_name': 'Doe',\r\n            'birth_date': '1954-03-29',\r\n        }, {\r\n            'first_name': 'Jane',\r\n            'last_name': 'Doh',\r\n            'birth_date': '1958-01-13',\r\n        }])\r\n```\r\n\r\n* ``supported_accept_types`` defines the supported encoding types and rejects\r\n  requests only does not accept `application/json`\r\n* Since the `get` method is only defined, `post`, `put`, `patch`, and\r\n  `delete` are not allowed for this resource. `head` is accessible if\r\n  `get` is defined and `options` is always available unless the service\r\n  is set as unavailable\r\n\r\n---\r\n\r\n## Composite Resources\r\n\r\nWhen designing a REST API, an important decision to make up front is\r\nwhether a _chatty_ service is preferred, or a service that requires\r\nmore bandwith per request.\r\n\r\nThe latter of the two is a result of embedding resources in other related\r\nresources. For example, the first response entity below simply has a\r\nreference to the endpoint where author `id` is available. Thus in order to\r\nget the data about the author, a second request is required.\r\n\r\nThe second response entity has the author data embedded in the book data.\r\nThis will require more bandwith, but will not require subsequent requests.\r\n\r\n```javascript\r\n// Referenced\r\n{\r\n    \"title\": \"Learn Python The Hard Way\",\r\n    \"publish_date\": \"2010-05-01\",\r\n    \"author\": {\r\n        \"id\": 1,\r\n        \"url\": \"http://example.com/author/1\"\r\n    }\r\n}\r\n\r\n// Embedded\r\n{\r\n    \"id\": 1,\r\n    \"title\": \"Learn Python The Hard Way\",\r\n    \"publish_date\": \"2010-05-01\",\r\n    \"author\": {\r\n        \"id\": 1,\r\n        \"first_name\": \"Zed\",\r\n        \"last_name\": \"Shaw\"\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nDeciding whether to embed data in another entity can be answered with a\r\nsimple question:\r\n\r\n> Is it likely the two entities are represented together in client\r\napplications?\r\n\r\nNote that embedding resources does not preclude resources from having their\r\nown endpoints (as in the first example).\r\n\r\nFor a large collection of objects, choosing to not embed related resources\r\nresults in the client needing to potentially make hundreds or thousands\r\nadditional requests.\r\n\r\nRESTlib2 provides an API for reusing resources by either referencing them\r\n(first example) or embedding them directly (second example).\r\n\r\n```python\r\n>>> book = Book()\r\n>>> book.apply_get()\r\n[{ ... }, ...]\r\n>>> book.apply_get(pk=1)\r\n{ ... }\r\n```\r\n\r\n---\r\n\r\n### Utilities for Models and QuerySets\r\n\r\n``restlib2.utils.serialize`` is a one-stop shop for ensuring an object\r\nis free of `Model` and `QuerySet` instances. By default, all non-relational\r\nfields will be included as well as the primary keys of local related fields.\r\nThus a serialized user object might look like this:\r\n\r\n```python\r\n>>> serialize(user)\r\n{\r\n    'date_joined': datetime.datetime(2009, 5, 16, 15, 52, 40),\r\n    'email': u'jon@doe.com',\r\n    'first_name': u'Jon',\r\n    'groups': [5],\r\n    'id': 1,\r\n    'is_active': True,\r\n    'is_staff': True,\r\n    'is_superuser': True,\r\n    'last_login': datetime.datetime(2012, 3, 3, 17, 40, 41, 927637),\r\n    'last_name': u'Doe',\r\n    'password': u'!',\r\n    'user_permissions': [1, 2, 3],\r\n    'username': u'jdoe'\r\n}\r\n```\r\n\r\nThis can then be passed off to an encoder, e.g. JSON, to turn it into a string for\r\nthe response body.\r\n\r\nSome of these fields may not be appropriate or relevent to include in the response.\r\nTo customize which fields get included or excluded, the following arguments can be\r\npassed to ``serialize``:\r\n\r\n* `fields` - A list of fields names to include. Method names can also be\r\nspecified that will be called when being serialized. Default is all fields\r\nand local related fields. See also: `exclude`, `key_map`\r\n* `exclude` - A list of fields names to exclude (this takes precedence\r\nover fields). Default is `None`. See also: `fields`, `key_map`\r\n* `related` - A dict of related object accessor and configs (see below) for\r\nhandling related object.\r\n* `values_list` - This option only applies to `QuerySet`s. Returns a list of\r\nlists which the field values (like Django's `ValuesListQuerySet`). Default is\r\n`False`.\r\n* `flatten` - Applies only if `values_list` is `True` and one field is specified.\r\nIf `True`, flattens out the list of lists into a single list of values. Default is\r\n`True`.\r\n* `key_prefix` - A string to be use to prefix the dictionary keys. To enable dynamic\r\nprefixes, the prefix may contain `'%(accessor)s'` which will be the class name for\r\ntop-level objects or the accessor name for related objects. Default is `None`.\r\n* `key_map` - A dict that maps  the keys of the output dictionary to the actual\r\nfield/method names referencing the data. Default is `None`.  See also: `fields`\r\n* `camelcase` - Converts all keys to a camel-case equivalent. This is merely a\r\nconvenience for conforming to language convention for consumers of this content,\r\ne.g. JavaScript. Default is `False`.\r\n\r\n```python\r\n>>> serialize(user, fields=['username', 'full_name'], key_map={'full_name': 'get_full_name'}, camelcase=True)\r\n{\r\n    'fullName': u'Jon Doe',\r\n    'username': u'jdoe'\r\n}\r\n\r\n>>> serialize(user, exclude=['password', 'groups', 'permissions'])\r\n{\r\n    'date_joined': datetime.datetime(2009, 5, 16, 15, 52, 40),\r\n    'email': u'jon@doe.com',\r\n    'first_name': u'Jon',\r\n    'id': 1,\r\n    'is_active': True,\r\n    'is_staff': True,\r\n    'is_superuser': True,\r\n    'last_login': datetime.datetime(2012, 3, 3, 17, 40, 41, 927637),\r\n    'last_name': u'Doe',\r\n    'username': u'jdoe'\r\n}\r\n```\r\n\r\n### Related Objects\r\n\r\nComposite resources are common when dealing with data with tight relationships.\r\nThe above `Author` and `Book` example is a good example of this. It is inefficient\r\nfor a client to have to make two separate requests for data that is typically\r\nalways consumed together.\r\n\r\n`serialize` supports the `related` keyword argument for defining options for\r\nrelational fields. The following additional attributes (to the above) may be\r\ndefined:\r\n\r\n* `merge` - This option only applies to local `ForeignKey` or `OneToOneField`. This\r\nallows for merging this object's fields into the parent object, e.g. a user and\r\ntheir profile.\r\n\r\n```python\r\n>>> serialize(user, related={'groups': {'fields': ['name'], 'profile': {'merge': True}}})\r\n{\r\n    'username': u'jdoe',\r\n    'groups': [{\r\n        'name': u'Managers'\r\n    }]\r\n    # profile attributes merged into the user\r\n    'twitter': '@jdoe',\r\n    'mobile': '123-456-7890',\r\n    ...\r\n}\r\n```","name":"restlib2"}